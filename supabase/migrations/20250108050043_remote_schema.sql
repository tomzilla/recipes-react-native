revoke delete on table "public"."curated_recipes" from "anon";

revoke insert on table "public"."curated_recipes" from "anon";

revoke references on table "public"."curated_recipes" from "anon";

revoke select on table "public"."curated_recipes" from "anon";

revoke trigger on table "public"."curated_recipes" from "anon";

revoke truncate on table "public"."curated_recipes" from "anon";

revoke update on table "public"."curated_recipes" from "anon";

revoke delete on table "public"."curated_recipes" from "authenticated";

revoke insert on table "public"."curated_recipes" from "authenticated";

revoke references on table "public"."curated_recipes" from "authenticated";

revoke select on table "public"."curated_recipes" from "authenticated";

revoke trigger on table "public"."curated_recipes" from "authenticated";

revoke truncate on table "public"."curated_recipes" from "authenticated";

revoke update on table "public"."curated_recipes" from "authenticated";

revoke delete on table "public"."curated_recipes" from "service_role";

revoke insert on table "public"."curated_recipes" from "service_role";

revoke references on table "public"."curated_recipes" from "service_role";

revoke select on table "public"."curated_recipes" from "service_role";

revoke trigger on table "public"."curated_recipes" from "service_role";

revoke truncate on table "public"."curated_recipes" from "service_role";

revoke update on table "public"."curated_recipes" from "service_role";

alter table "public"."curated_recipes" drop constraint "fk_curated_recipes_recipe";

drop index if exists "public"."idx_curated_recipes_recipe";

drop table "public"."curated_recipes";

alter table "public"."meal_plan" add column "id" bigint generated by default as identity not null;

alter table "public"."meal_plan" enable row level security;

CREATE UNIQUE INDEX meal_plan_id_key ON public.meal_plan USING btree (id);

CREATE UNIQUE INDEX meal_plan_pkey ON public.meal_plan USING btree (id);

alter table "public"."meal_plan" add constraint "meal_plan_pkey" PRIMARY KEY using index "meal_plan_pkey";

alter table "public"."meal_plan" add constraint "meal_plan_id_key" UNIQUE using index "meal_plan_id_key";

set check_function_bodies = off;

create or replace view "public"."future_meal_plan_count" as  SELECT count(1) AS count
   FROM meal_plan
  WHERE ((meal_plan.user_id = ( SELECT auth.uid() AS uid)) AND (meal_plan.plan_date > now()));


create or replace view "public"."meal_plan_count" as  SELECT count(1) AS count
   FROM meal_plan
  WHERE (meal_plan.user_id = ( SELECT auth.uid() AS uid));


CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    BEGIN
        INSERT INTO public.user_profiles VALUES (NEW.id, 'free');
        RETURN NEW;
    EXCEPTION WHEN OTHERS THEN
        -- Insert exception info into debug_log for debugging (not doing anything)

        RAISE LOG '%', SQLERRM;
        RETURN NULL;
    END;

END;
$function$
;

create policy "own_meal_plan"
on "public"."meal_plan"
as permissive
for all
to public
using ((user_id = ( SELECT auth.uid() AS uid)))
with check (((user_id = ( SELECT auth.uid() AS uid)) AND (( SELECT future_meal_plan_count.count
   FROM future_meal_plan_count) < 100)));


create policy "can_save_recipe"
on "public"."saved_recipes"
as permissive
for insert
to public
with check (((user_id = ( SELECT auth.uid() AS uid)) AND (( SELECT count(1) AS count
   FROM saved_recipes saved_recipes_1
  WHERE (saved_recipes_1.user_id = ( SELECT auth.uid() AS uid))) < 1000)));


create policy "own_profile"
on "public"."user_profiles"
as permissive
for all
to public
using ((( SELECT auth.uid() AS uid) = id))
with check ((( SELECT auth.uid() AS uid) = id));



